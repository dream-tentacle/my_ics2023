<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>PA2 &#x5fc5;&#x7b54;&#x9898;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="pa2-必答题">PA2 必答题</h1>
<p>作者：熊浚丞 221240060</p>
<h3 id="程序是个状态机">程序是个状态机</h3>
<ul>
<li>画出在YEMU上执行的加法程序的状态机
加法执行的状态机如下，其余未列出的M均不改变故没有写出。
pc = 0, R = {0,0}, halt = 0, M[7] = 0 -&gt;
pc = 1, R = {33,0}, halt = 0, M[7] = 0 -&gt;
pc = 2, R = {33,33}, halt = 0, M[7] = 0 -&gt;
pc = 3, R = {16,33}, halt = 0, M[7] = 0 -&gt;
pc = 4, R = {49,33}, halt = 0, M[7] = 0 -&gt;
pc = 5, R = {49,33}, halt = 0, M[7] = 49 -&gt;
pc = 5, R = {49,33}, halt = 1, M[7] = 49 终止状态（自环）</li>
<li>通过RTFSC理解YEMU如何执行一条指令
首先通过M[pc]取指，然后判断前四位的情况，按照R或M型指令进行提取参数，然后进行操作，并更新pc；若前四位不对应指令，则将halt设为1，停止。</li>
</ul>
<h3 id="rtfsc-请整理一条指令在nemu中的执行过程">RTFSC 请整理一条指令在NEMU中的执行过程</h3>
<ol>
<li>在<code>exec_once</code>中调用<code>isa_exec_once</code>，准备执行指令</li>
<li>执行<code>inst_fetch</code>，在内存的pc地址处读取，来获取指令内容，同时将静态下条pc设为当前pc+4</li>
<li><code>isa_exec_once</code>再调用<code>decode_exec</code></li>
<li><code>decode_exec</code>的过程：
<ol>
<li>将动态下条pc暂时设为静态下条pc</li>
<li>按顺序依次匹配指令模式，如果匹配成功，则根据指令类型提取参数到src1,rd等变量中</li>
<li>根据匹配到的指令执行相应功能</li>
<li>将0寄存器设为0，从而无须在指令执行时特判</li>
</ol>
</li>
<li>返回到<code>exec_once</code>，将pc设为dnpc</li>
</ol>
<h3 id="程序如何运行-理解打字小游戏如何运行">程序如何运行 理解打字小游戏如何运行</h3>
<ul>
<li>main函数过程：</li>
</ul>
<ol>
<li>初始化</li>
<li>进入while循环，即游戏主内容</li>
<li>在while循环中，首先获取到当前经过的时间帧数，然后反复更新游戏逻辑帧，直到逻辑帧达到经过的时间帧数</li>
<li>逐个匹配输入的按键直到没有更多的未处理按键，如果按下退出键则终止游戏</li>
<li>如果逻辑时间大于渲染时间，渲染一次并更新渲染时间</li>
</ol>
<ul>
<li>游戏逻辑帧更新：每秒设定了30帧，每秒出现5个新字符，因此每6个逻辑帧产生一个新字符。对于所有字符，每帧下降一段距离，如果超出屏幕则删除。</li>
<li>处理按键：如果字符在最下方且与按键相等，则匹配上，并将字符速度设为向上的很大速度，这样在y值为负时就会在逻辑帧中删除</li>
<li>渲染：先清空，然后将字符全部打印出来，再在终端重新打印分数的信息</li>
</ul>
<h3 id="编译与链接">编译与链接</h3>
<ul>
<li>在<code>nemu/include/cpu/ifetch.h</code>中, 你会看到由static inline开头定义的inst_fetch()函数. 分别尝试去掉static, 去掉inline或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生/不发生? 你有办法证明你的想法吗?</li>
</ul>
<p>只有都去掉才会发生错误，发生了重复定义错误。static的效果是使函数仅在当前文件生效，加上后即使多个文件include了ifetch.h，也不会冲突；inline的效果是内联展开，相当于把函数内容复制到调用处，编译器不会将它进行冲突判定。两个都去掉后才会冲突。证明：发现该函数被hostcall.c和inst.c调用，而把前者的include删除并去掉相应代码后，就没有冲突了。</p>
<h3 id="编译与链接-1">编译与链接</h3>
<ol>
<li>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个dummy变量的实体? 你是如何得到这个结果的?</li>
</ol>
<p>32个，因为修改后编译时，有32个文件被重新编译</p>
<ol start="2">
<li>添加上题中的代码后, 再在<code>nemu/include/debug.h</code>中添加一行<code>volatile static int dummy;</code> 然后重新编译NEMU. 请问此时的NEMU含有多少个dummy变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果.</li>
</ol>
<p>32个，因为被重新编译的文件都一样，对于这些文件，是两个重复的弱定义，所以不变。</p>
<ol start="3">
<li>修改添加的代码, 为两处dummy变量进行初始化:<code>volatile static int dummy = 0; </code>然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)</li>
</ol>
<p>报了很多重复声明的错误，因为这是两个重复的强定义，是不允许的。</p>
<h3 id="了解makefile">了解Makefile</h3>
<ul>
<li>请描述你在<code>am-kernels/kernels/hello/</code>目录下敲入<code>make ARCH=$ISA-nemu</code> 后, make程序如何组织<code>.c</code>和<code>.h</code>文件, 最终生成可执行文件<code>am-kernels/kernels/hello/build/hello-$ISA-nemu.elf.</code> (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:
<ul>
<li>Makefile中使用了变量, 包含文件等特性</li>
<li>Makefile运用并重写了一些implicit rules</li>
<li>在man make中搜索-n选项, 也许会对你有帮助</li>
<li>RTFM</li>
</ul>
</li>
</ul>
<p>首先将NAME和SRCS都设置为要编译的文件<code>hello.c</code>，然后include了am的makefile（相当于复制）。在该makefile中，有许多变量和规则。首先检查了ARCH是不是可以支持的，不支持则会直接打印报错并终止。然后将ARCH分为ISA和平台。通过SRCS获取OBJS，并收集了需要链接的文件名。同时，从SRCS、ISA等已获取到的变量将各种需要用在c文件中的define放入了CFLAGS等选项中。最后，定义了许多用于编译、链接的规则，这些规则是根据形如<code>$(DST_DIR)/%.o: %.c</code>的命令定义的，它会把所有符合格式的文件都定义一个规则，并将他们加上相应的地址前缀，实现了批量定义规则。</p>
<p>编译链接的过程：</p>
<ol>
<li>将所有<code>.c</code>,<code>.cc</code>,<code>.cpp</code>和<code>.S</code>文件编译为DST_DIR路径下的<code>.o</code>文件，在编译时调用了相应文件类型的编译选项变量</li>
<li>将<code>.o</code>文件和<code>.a</code>文件进行链接并生成<code>IMAGE.elf</code>文件，并调用了之前定义的编译选项变量</li>
</ol>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>